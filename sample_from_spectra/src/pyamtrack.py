#! /usr/bin/env python
'''
    pyamtrack.py
    =========
   Author: herrmann

   Python interface for the libamtrack functions defined in NAMESPACE file
   this script is generated by generate_Py_wrapper.py

   Requirements: Python2.6

   Copyright 2006, 2011 Steffen Greilich / the libamtrack team

   This file is part of the AmTrack program (libamtrack.sourceforge.net).

   AmTrack is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   AmTrack is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with AmTrack (file: copying.txt).
   If not, see <http://www.gnu.org/licenses/>
'''


import ctypes
import string
import os
import sys
from platform import python_version
from platform import system as os_system

__status__ = 'Prototype'

operating_system = os_system()
if operating_system == 'Windows':
	libamtrack = ctypes.cdll.libamtrack
else:
	os.environ['LD_LIBRARY_PATH']='./libamtrack.so'
	libamtrack = ctypes.cdll.LoadLibrary("./libamtrack.so")

py_version = python_version()
if int(py_version[0]) < 3 and int(py_version[2]) <= 5:
	print 'ERROR:\nYou are using Python%s\nPython2.6 or later needed!\n'%py_version
	sys.exit(1)



def AT_Stopping_Power ( stopping_power_source, n, E_MeV_u, particle_no, material_no, stopping_power_keV_um):
	'''
	 * Retrieves the electronic stopping power in keV/um for
	 * the requested energies and particles for a specified
	 * material and data source. The data source is thereby
	 * given via its name (s. AT_StoppingPowerData.h for
	 * details), except for data that should be read from
	 * a file, in this case the (path and) filename has to be
	 * provided. In this case, the user has to make sure that
	 * energy and stopping power units are correct and that
	 * the data match the given material (use material.no = 0
	 * for custom-defined material) for density scaling.
	 * 
	 * The file has to be plain
	 * ASCII with three columns (separated by space)
	 *    charge, energy, and stopping power
	 * and sorted in ascending order by first charge than energy
	 * any alphanumeric comment can be inserted (in separate
	 * lines)
	 *
	 * @param[in]   stopping_power_source		name of the data source
	 * @param[in]   n							number of energies / particles
	 * @param[in]   E_MeV_u						kinetic energies in MeV per amu (array of size n)
	 * @param[in]   particle_no                 particle numbers (array of size n)
	 * @param[in]   material_no                 material number
	 * @param[out]  stopping_power_keV_um       array to return stopping powers (array of size n)
	 * @return		status
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_stopping_power_keV_um= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_stopping_power_source = ctypes.c_char_p(stopping_power_source)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Stopping_Power
	c_function.restype = ctypes.c_int
	c_output = c_function( c_stopping_power_source, c_n, c_E_MeV_u, c_particle_no, c_material_no, c_stopping_power_keV_um)
	return c_output,  c_stopping_power_keV_um._obj


def AT_D_RDD_Gy ( n, r_m, E_MeV_u, particle_no, material_no, rdd_model, rdd_parameter, er_model, stopping_power_source_no, D_RDD_Gy):
	'''
	 * Returns local dose as a function of distance r_m for a given radial dose distribution model
	 *
	 * @param[in]   n              number of particles (length of r_m vector)
	 * @param[in]   r_m            distance [m] (array of size n)
	 * @param[in]   E_MeV_u        particle (ion) energy per nucleon [MeV/u] (single number, no mixed fields)
	 * @param[in]   particle_no    particle code number (single number, no mixed fields)
	 * @param[in]   material_no    material code number (single number, no mixed fields)
	 * @param[in]   rdd_model      radial dose distribution model index
	 * @param[in]   rdd_parameter  radial dose distribution model parameters (array of size 4)
	 * @param[in]   er_model       electron range / track with model index
	 * @param[in]   stopping_power_source_no  TODO
	 * @param[out]  D_RDD_Gy       dose [Gy] (array of size n)
	 * @return status code
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	tmp_array =ctypes.c_double* len(rdd_parameter)
	c_rdd_parameter = ctypes.byref(tmp_array(*rdd_parameter))

	tmp_array = (ctypes.c_double*n)()
	c_D_RDD_Gy= ctypes.byref(tmp_array)

	c_E_MeV_u = ctypes.c_double(E_MeV_u)
	c_er_model = ctypes.c_long(er_model)
	tmp_array =ctypes.c_double* len(r_m)
	c_r_m = ctypes.byref(tmp_array(*r_m))

	c_particle_no = ctypes.c_long(particle_no)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_D_RDD_Gy
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_r_m, c_E_MeV_u, c_particle_no, c_material_no, c_rdd_model, c_rdd_parameter, c_er_model, c_stopping_power_source_no, c_D_RDD_Gy)
	return c_output,  c_D_RDD_Gy._obj


def AT_material_name_from_number ( material_no, material_name):
	'''
	 * Get material name
	 * @param[in]  material_no
	 * @param[out] material_name
	'''
	c_material_no = ctypes.c_long(material_no)
	c_material_name =  ctypes.byref(ctypes.c_char(material_name))

	c_function =  libamtrack.AT_material_name_from_number
	c_output = c_function( c_material_no, c_material_name)
	return c_output,  c_material_name._obj.value


def AT_get_materials_data ( number_of_materials, material_no, density_g_cm3, I_eV, alpha_g_cm2_MeV, p_MeV, m_g_cm2, average_A, average_Z):
	'''
	 * Returns material data for list of materials
	 * @param[in]   number_of_materials  numbers of materials the routine is called for
	 * @param[in]   material_no          material indices (array of size number_of_materials)
	 * @param[out]  density_g_cm3        material density in g/cm3 (array of size number_of_materials)
	 * @param[out]  I_eV                 mean ionization potential in eV (array of size number_of_materials)
	 * @param[out]  alpha_g_cm2_MeV      fit parameter for power-law representation of stp.power/range/E-dependence (array of size number_of_materials)
	 * @param[out]  p_MeV                fit parameter for power-law representation of stp.power/range/E-dependence (array of size number_of_materials)
	 * @param[out]  m_g_cm2              fit parameter for the linear representation of fluence changes due to nuclear interactions based on data from Janni 1982 (array of size number_of_materials)
	 * @param[out]  average_A            average mass number (array of size number_of_materials)
	 * @param[out]  average_Z            average atomic number (array of size number_of_materials)
	'''
	tmp_array =ctypes.c_long* len(material_no)
	c_material_no = ctypes.byref(tmp_array(*material_no))

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_average_A= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_alpha_g_cm2_MeV= ctypes.byref(tmp_array)

	c_number_of_materials = ctypes.c_long(number_of_materials)
	tmp_array = (ctypes.c_double*number_of_materials)()
	c_density_g_cm3= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_m_g_cm2= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_I_eV= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_average_Z= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*number_of_materials)()
	c_p_MeV= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_get_materials_data
	c_output = c_function( c_number_of_materials, c_material_no, c_density_g_cm3, c_I_eV, c_alpha_g_cm2_MeV, c_p_MeV, c_m_g_cm2, c_average_A, c_average_Z)
	return c_output,  c_density_g_cm3._obj, c_I_eV._obj, c_alpha_g_cm2_MeV._obj, c_p_MeV._obj, c_m_g_cm2._obj, c_average_A._obj, c_average_Z._obj


def AT_electron_density_m3_from_material_no_multi ( n, material_no, electron_density_m3):
	'''
	 * Get electron density [1/m3] for materials
	 * @param[in]     n                    number of materials
	 * @param[in]     material_no          material indices (array of size n)
	 * @param[out]    electron_density_m3  electron densities per m3 (array of size n)
	'''
	tmp_array =ctypes.c_long* len(material_no)
	c_material_no = ctypes.byref(tmp_array(*material_no))

	tmp_array = (ctypes.c_double*n)()
	c_electron_density_m3= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_electron_density_m3_from_material_no_multi
	c_output = c_function( c_n, c_material_no, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj


def AT_electron_density_m3_multi ( n, density_g_cm3, average_A, average_Z, electron_density_m3):
	'''
	 * Returns electron density from average A and Z
	 * @param[in]   n                    size of arrays
	 * @param[in]   density_g_cm3        material density in g/cm3 (array of size n)
	 * @param[in]   average_A            average mass number (array of size n)
	 * @param[in]   average_Z            average atomic number (array of size n)
	 * @param[out]  electron_density_m3  electron density in 1/m3 (array of size n)
	'''
	tmp_array =ctypes.c_double* len(average_A)
	c_average_A = ctypes.byref(tmp_array(*average_A))

	tmp_array =ctypes.c_double* len(density_g_cm3)
	c_density_g_cm3 = ctypes.byref(tmp_array(*density_g_cm3))

	tmp_array = (ctypes.c_double*n)()
	c_electron_density_m3= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(average_Z)
	c_average_Z = ctypes.byref(tmp_array(*average_Z))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_electron_density_m3_multi
	c_output = c_function( c_n, c_density_g_cm3, c_average_A, c_average_Z, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj


def AT_electron_density_m3_from_composition ( n, density_g_cm3, Z, A, weight_fraction, electron_density_m3):
	'''
	 * Computes the electron density for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  density_g_cm3         physical density (in g per cm3) of material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] electron_density_m3   electron density per m3
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_n = ctypes.c_long(n)
	c_electron_density_m3 =  ctypes.byref(ctypes.c_double(electron_density_m3))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_electron_density_m3_from_composition
	c_output = c_function( c_n, c_density_g_cm3, c_Z, c_A, c_weight_fraction, c_electron_density_m3)
	return c_output,  c_electron_density_m3._obj.value


def AT_average_A_from_composition ( n, A, weight_fraction, average_A):
	'''
	 * Computes the average mass number for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] average_A             average A
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_average_A =  ctypes.byref(ctypes.c_double(average_A))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_average_A_from_composition
	c_output = c_function( c_n, c_A, c_weight_fraction, c_average_A)
	return c_output,  c_average_A._obj.value


def AT_average_Z_from_composition ( n, Z, weight_fraction, average_Z):
	'''
	 * Computes the average atomic number for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] average_Z             average Z
	'''
	c_average_Z =  ctypes.byref(ctypes.c_double(average_Z))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_average_Z_from_composition
	c_output = c_function( c_n, c_Z, c_weight_fraction, c_average_Z)
	return c_output,  c_average_Z._obj.value


def AT_effective_Z_from_composition ( n, Z, weight_fraction, electron_densities_cm3, exponent, effective_Z):
	'''
	 * Computes the effective atomic number for a given material composition
	 *
	 * @param[in]  n                     	number of constituents in material
	 * @param[in]  Z                     	atomic numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       	relative fractions of weight of constituents (array of size n)
	 * @param[in]  electron_densities_cm3   if not zero, weight fractions will additionally include electron densities per volume (array of size n)
	 * @param[in]  exponent              	exponent for additivity rule reflecting the photon energy regime (usually 3.5 at ~ 100 kV)
	 * @param[out] effective_Z           	effective Z
	'''
	c_exponent = ctypes.c_double(exponent)
	tmp_array =ctypes.c_double* len(electron_densities_cm3)
	c_electron_densities_cm3 = ctypes.byref(tmp_array(*electron_densities_cm3))

	c_effective_Z =  ctypes.byref(ctypes.c_double(effective_Z))

	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_effective_Z_from_composition
	c_output = c_function( c_n, c_Z, c_weight_fraction, c_electron_densities_cm3, c_exponent, c_effective_Z)
	return c_output,  c_effective_Z._obj.value


def AT_I_eV_from_composition ( n, Z, A, weight_fraction, I_eV):
	'''
	 * Computes the I value for a given material composition
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] I_eV                  I value in eV
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_I_eV =  ctypes.byref(ctypes.c_double(I_eV))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_I_eV_from_composition
	c_output = c_function( c_n, c_Z, c_A, c_weight_fraction, c_I_eV)
	return c_output,  c_I_eV._obj.value


def AT_set_user_material ( density_g_cm3, I_eV, average_A, average_Z, status):
	'''
	 * Initializes user defined material. The material can then be used with material index number 0. !Be aware! that is
	 * definition is only valid during run-time. When the library is reloaded, the default settings are restored and the
	 * material is removed.
	 * @param[in] density_g_cm3  physical density in g per cm3
	 * @param[in] I_eV           I value in eV
	 * @param[in] average_A      average mass number
	 * @param[in] average_Z      average atomic number
	 * @param[out] status        material defined successfully if zero
	'''
	c_average_A = ctypes.c_double(average_A)
	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_average_Z = ctypes.c_double(average_Z)
	c_status =  ctypes.byref(ctypes.c_long(status))

	c_I_eV = ctypes.c_double(I_eV)
	c_function =  libamtrack.AT_set_user_material
	c_output = c_function( c_density_g_cm3, c_I_eV, c_average_A, c_average_Z, c_status)
	return c_output,  c_status._obj.value


def AT_set_user_material_from_composition ( n, density_g_cm3, Z, A, weight_fraction, status):
	'''
	 * Initializes user defined material from composition data. The material can then be used with material index number 0. !Be aware! that is
	 * definition is only valid during run-time. When the library is reloaded, the default settings are restored and the
	 * material is removed.
	 *
	 * @param[in]  n                     number of constituents in material
	 * @param[in]  density_g_cm3         physical density (in g per cm3) of material
	 * @param[in]  Z                     atomic numbers of constituents (array of size n)
	 * @param[in]  A                     mass numbers of constituents (array of size n)
	 * @param[in]  weight_fraction       relative fractions of weight of constituents (array of size n)
	 * @param[out] status                material defined successfully if zero
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	c_status =  ctypes.byref(ctypes.c_long(status))

	c_density_g_cm3 = ctypes.c_double(density_g_cm3)
	c_n = ctypes.c_long(n)
	tmp_array =ctypes.c_double* len(weight_fraction)
	c_weight_fraction = ctypes.byref(tmp_array(*weight_fraction))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	c_function =  libamtrack.AT_set_user_material_from_composition
	c_output = c_function( c_n, c_density_g_cm3, c_Z, c_A, c_weight_fraction, c_status)
	return c_output,  c_status._obj.value


def AT_SPC_read_header_from_filename_fast ( filename, E_MeV_u, peak_position_g_cm2, particle_no, material_no, normalisation, depth_steps_no):
	'''
	 * Reads data from spc file into pre-allocated arrays. It will be converted
	 * for direct use in libamtrack, i.e. to an R-style array of six columns
	 * (each presented by a single pointer) and all of same length. That of course
	 * results in redundancy in depth_step, depth_g_cm2, particle_no but enables
	 * easy division into cells (i.e. passing all spectra of a specific depth and
	 * particle number to another routine such as total dose). Please note that
	 * the fluence IS NOT normalized to bin width but given in absolute fluence!
	 *
	 * @param[in]	filename  	    	path and name for spc file, incl. extension
	 * @param[out]	E_MeV_u			primary beam energy in MeV/u
	 * @param[out]	peak_position_g_cm2	position of peak in g/cm2
	 * @param[out]	particle_no         projectile - particle no
	 * @param[out]	material_no         target - material no
	 * @param[out]	normalisation		normalisation
	 * @param[out]  depth_steps_no      number of depth steps
	 * @return               status code
	'''
	c_material_no =  ctypes.byref(ctypes.c_int(material_no))

	c_depth_steps_no =  ctypes.byref(ctypes.c_int(depth_steps_no))

	c_peak_position_g_cm2 =  ctypes.byref(ctypes.c_double(peak_position_g_cm2))

	c_E_MeV_u =  ctypes.byref(ctypes.c_double(E_MeV_u))

	c_particle_no =  ctypes.byref(ctypes.c_long(particle_no))

	c_normalisation =  ctypes.byref(ctypes.c_double(normalisation))

	c_filename = ctypes.c_char_p(filename)

	c_function =  libamtrack.AT_SPC_read_header_from_filename_fast
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_E_MeV_u, c_peak_position_g_cm2, c_particle_no, c_material_no, c_normalisation, c_depth_steps_no)
	return c_output,  c_E_MeV_u._obj.value, c_peak_position_g_cm2._obj.value, c_particle_no._obj.value, c_material_no._obj.value, c_normalisation._obj.value, c_depth_steps_no._obj.value


def AT_SPC_read_from_filename_fast ( filename, n, E_MeV_u_initial, peak_position_g_cm2, particle_no_initial, material_no, normalisation, depth_steps_no, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * Reads data from spc file into pre-allocated arrays. It will be converted
	 * for direct use in libamtrack, i.e. to an R-style array of six columns
	 * (each presented by a single pointer) and all of same length. That of course
	 * results in redundancy in depth_step, depth_g_cm2, particle_no but enables
	 * easy division into cells (i.e. passing all spectra of a specific depth and
	 * particle number to another routine such as total dose). Please note that
	 * the fluence IS NOT normalized to bin width but given in absolute fluence!
	 *
	 * @param[in]	filename  	    	path and name for spc file, incl. extension
	 * @param[in]   n                   array size, total number of bins expected
	 * @see AT_SPC_get_size
	 * @param[out]	E_MeV_u_initial		primary beam energy in MeV/u
	 * @param[out]	peak_position_g_cm2	position of peak in g/cm2
	 * @param[out]	particle_no_initial projectile - particle no
	 * @param[out]	material_no         target - material no
	 * @param[out]	normalisation		normalisation
	 * @param[out]  depth_steps_no      number of depth steps
	 * @param[out]	depth_step		    depth step index, zero-based (array of size n)
	 * @param[out]	depth_g_cm2		    depth in g/cm2 (array of size n)
	 * @param[out]	E_MeV_u			    midpoints of energy bins (array of size n)
	 * @param[out]	DE_MeV_u		    widths of energy bins (array of size n)
	 * @param[out]	particle_no		    particle index numbers (array of size n)
	 * @param[out]  fluence_cm2		    fluence values differential in energy and particle number (array of size n)
	 * @return                          number of bins read. Must match the array size n
	'''
	c_material_no =  ctypes.byref(ctypes.c_int(material_no))

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	c_depth_steps_no =  ctypes.byref(ctypes.c_int(depth_steps_no))

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	c_n = ctypes.c_int(n)
	tmp_array = (ctypes.c_int*n)()
	c_depth_step= ctypes.byref(tmp_array)

	c_particle_no_initial =  ctypes.byref(ctypes.c_long(particle_no_initial))

	c_peak_position_g_cm2 =  ctypes.byref(ctypes.c_double(peak_position_g_cm2))

	c_normalisation =  ctypes.byref(ctypes.c_double(normalisation))

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_filename = ctypes.c_char_p(filename)

	tmp_array = (ctypes.c_double*n)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	c_E_MeV_u_initial =  ctypes.byref(ctypes.c_double(E_MeV_u_initial))

	c_function =  libamtrack.AT_SPC_read_from_filename_fast
	c_function.restype = ctypes.c_int
	c_output = c_function( c_filename, c_n, c_E_MeV_u_initial, c_peak_position_g_cm2, c_particle_no_initial, c_material_no, c_normalisation, c_depth_steps_no, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj, c_E_MeV_u_initial._obj.value, c_peak_position_g_cm2._obj.value, c_particle_no_initial._obj.value, c_material_no._obj.value, c_normalisation._obj.value, c_depth_steps_no._obj.value, c_depth_step._obj


def AT_SPC_number_of_bins_at_range ( path, range_g_cm2):
	'''
	 * TODO
	 *
	 * @param[in]   path            	path to spc file dir (array of size 2048)
	 * @param[in]   range_g_cm2         range in g/cm2
	 * @return                          number of bins for given range
	'''
	c_path = ctypes.c_char_p(path)

	c_range_g_cm2 = ctypes.c_double(range_g_cm2)
	c_function =  libamtrack.AT_SPC_number_of_bins_at_range
	c_function.restype = ctypes.c_long
	c_output = c_function( c_path, c_range_g_cm2)
	return c_output


def AT_SPC_spectrum_at_range ( path, range_g_cm2, n, depth_step, depth_g_cm2, E_MeV_u, DE_MeV_u, particle_no, fluence_cm2):
	'''
	 * TODO
	 *
	 * @param[in]   path            	path to spc file dir (array of size 2048)
	 * @param[in]   range_g_cm2         range in g/cm2
	 * @param[in]   n                   array size, total number of bins expected
	 * @param[out]	depth_step		    depth step index, zero-based (array of size n)
	 * @param[out]	depth_g_cm2		    depth in g/cm2 (array of size n)
	 * @param[out]	E_MeV_u			    midpoints of energy bins (array of size n)
	 * @param[out]	DE_MeV_u		    widths of energy bins (array of size n)
	 * @param[out]	particle_no		    particle index numbers (array of size n)
	 * @param[out]  fluence_cm2		    fluence values differential in energy and particle number (array of size n)
	 * @return                          status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_DE_MeV_u= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	c_range_g_cm2 = ctypes.c_double(range_g_cm2)
	tmp_array = (ctypes.c_double*n)()
	c_depth_g_cm2= ctypes.byref(tmp_array)

	c_path = ctypes.c_char_p(path)

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_int(n)
	tmp_array = (ctypes.c_int*n)()
	c_depth_step= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_SPC_spectrum_at_range
	c_function.restype = ctypes.c_int
	c_output = c_function( c_path, c_range_g_cm2, c_n, c_depth_step, c_depth_g_cm2, c_E_MeV_u, c_DE_MeV_u, c_particle_no, c_fluence_cm2)
	return c_output,  c_depth_step._obj, c_depth_g_cm2._obj, c_E_MeV_u._obj, c_DE_MeV_u._obj, c_particle_no._obj, c_fluence_cm2._obj


def AT_particle_no_from_Z_and_A ( n, Z, A, particle_no):
	'''
	 * Returns particle index number from given A and Z
	 *
	 * @param[in]  n            array sizes
	 * @param[in]  Z            atomic numbers (array of size n)
	 * @param[in]  A            mass number (array of size n)
	 * @param[out] particle_no  corresponding particle index numbers (array of size n)
	 * @return status code
	'''
	tmp_array =ctypes.c_long* len(A)
	c_A = ctypes.byref(tmp_array(*A))

	tmp_array =ctypes.c_long* len(Z)
	c_Z = ctypes.byref(tmp_array(*Z))

	tmp_array = (ctypes.c_long*n)()
	c_particle_no= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_particle_no_from_Z_and_A
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_Z, c_A, c_particle_no)
	return c_output,  c_particle_no._obj


def AT_A_from_particle_no ( n, particle_no, A):
	'''
	 * Returns mass number for given particle number
	 * @param[in]  n                length of arrays
	 * @param[in]  particle_no      particle index number (array of size n)
	 * @param[out] A                mass number (array of size n)
	 * @return     return code
	'''
	tmp_array = (ctypes.c_long*n)()
	c_A= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_A_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_A)
	return c_output,  c_A._obj


def AT_Z_from_particle_no ( n, particle_no, Z):
	'''
	 * Returns atomic number for given particle number
	 * @param[in]  n               length of arrays
	 * @param[in]  particle_no     particle index number (array of size n)
	 * @param[out] Z               atomic number (array of size n)
	 * @return     return code
	'''
	tmp_array = (ctypes.c_long*n)()
	c_Z= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_Z_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_Z)
	return c_output,  c_Z._obj


def AT_particle_name_from_particle_no_single ( particle_no, particle_name):
	'''
	 * Returns particle index name for given particle index number
	 * @param[in]  particle_no    particle index number
	 * @param[out] particle_name  corresponding particle name
	 * @return status
	'''
	c_particle_name =  ctypes.byref(ctypes.c_char(particle_name))

	c_particle_no = ctypes.c_long(particle_no)
	c_function =  libamtrack.AT_particle_name_from_particle_no_single
	c_function.restype = ctypes.c_int
	c_output = c_function( c_particle_no, c_particle_name)
	return c_output,  c_particle_name._obj.value


def AT_particle_name_from_particle_no ( n, particle_no, particle_name):
	'''
	 * Returns particle index numbers for given particle names
	 * @param[in]  n             TODO
	 * @param[in]  particle_no   particle index numbers (array of size n)
	 * @param[out] particle_name corresponding particle names
	 * @return status
	'''
	c_particle_name =  ctypes.byref((particle_name))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_particle_name_from_particle_no
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_particle_no, c_particle_name)
	return c_output,  c_particle_name._obj.value


def AT_max_electron_ranges_m ( number_of_particles, E_MeV_u, material_no, er_model, max_electron_range_m):
	'''
	 * Returns the maximum electron range (track radius) in m
	 * for a given parametrization
	 *
	 * @param[in]  number_of_particles          number of particles in the incident field
	 * @param[in]  E_MeV_u                      kinetic energy for particles in the given field (array of size number_of_particles)
	 * @param[in]  material_no                  material index
	 * @param[in]  er_model                     electron-range model index
	 * @param[out] max_electron_range_m         electron range (track radius) in m  (array of size number_of_particles)
	'''
	c_material_no = ctypes.c_int(material_no)
	tmp_array = (ctypes.c_double*number_of_particles)()
	c_max_electron_range_m= ctypes.byref(tmp_array)

	c_er_model = ctypes.c_int(er_model)
	c_number_of_particles = ctypes.c_long(number_of_particles)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_max_electron_ranges_m
	c_output = c_function( c_number_of_particles, c_E_MeV_u, c_material_no, c_er_model, c_max_electron_range_m)
	return c_output,  c_max_electron_range_m._obj


def AT_CSDA_energy_after_slab_E_MeV_u_multi ( n, E_initial_MeV_u, particle_no, material_no, slab_thickness_m, E_final_MeV_u):
	'''
	 * Computes the ion energy after transversing a slab of material using Bethe stopping power
	 * and CSDA approach for many energies / particles
	 *
	 * @param[in]  	   n                    number of particles
	 * @param[in]  	   E_initial_MeV_u      initial energy of particle per nucleon (array of size n)
	 * @param[in]  	   particle_no          particle index (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]      material_no          material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]      slab_thickness_m     thickness of slab to transversed
	 * @param[out]     E_final_MeV_u        final energy after slab (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	c_n = ctypes.c_long(n)
	c_slab_thickness_m = ctypes.c_double(slab_thickness_m)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	tmp_array =ctypes.c_double* len(E_initial_MeV_u)
	c_E_initial_MeV_u = ctypes.byref(tmp_array(*E_initial_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_E_final_MeV_u= ctypes.byref(tmp_array)

	c_function =  libamtrack.AT_CSDA_energy_after_slab_E_MeV_u_multi
	c_output = c_function( c_n, c_E_initial_MeV_u, c_particle_no, c_material_no, c_slab_thickness_m, c_E_final_MeV_u)
	return c_output,  c_E_final_MeV_u._obj


def AT_beta_from_E ( n, E_MeV_u, beta):
	'''
	 *  Returns relativistic speed for many particles
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[out] beta                     vector of relative particle speed beta = v/c (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_beta= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beta_from_E
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_beta)
	return c_output,  c_beta._obj


def AT_E_from_beta ( n, beta, E_MeV_u):
	'''
	 *  Returns energy per nucleon of particle with relativistic speed beta
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  beta                     vector of relative particle speed beta = v/c (array of size n)
	 * @param[out] E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(beta)
	c_beta = ctypes.byref(tmp_array(*beta))

	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_E_from_beta
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_beta, c_E_MeV_u)
	return c_output,  c_E_MeV_u._obj


def AT_E_MeV_u_from_momentum_MeV_c_u ( n, momentum_MeV_c_u, E_MeV_u):
	'''
	 *  Returns energy per nucleon for particles with given momentum per nucleon
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  momentum_MeV_c_u         vector of particle momenta per nucleon [MeV/c], (array of size n)
	 * @param[out] E_MeV_u                  vector of energies of particle per nucleon [MeV], (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_E_MeV_u= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(momentum_MeV_c_u)
	c_momentum_MeV_c_u = ctypes.byref(tmp_array(*momentum_MeV_c_u))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_E_MeV_u_from_momentum_MeV_c_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_momentum_MeV_c_u, c_E_MeV_u)
	return c_output,  c_E_MeV_u._obj


def AT_gamma_from_E ( n, E_MeV_u, gamma):
	'''
	 *  Returns relativistic gamma
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[out] gamma                    vector of results (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_gamma= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_gamma_from_E
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_gamma)
	return c_output,  c_gamma._obj


def AT_effective_charge_from_E_MeV_u ( n, E_MeV_u, particle_no, effective_charge):
	'''
	 * Effective charge according to Barkas-Bethe-approximation:
	 * for particles with given kinetic energy per nucleon
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  vector of energies of particle per nucleon [MeV] (array of size n)
	 * @param[in]  particle_no              type of the particles in the mixed particle field (array of size n)
	 * @param[out] effective_charge         Effective charge according to Barkas-Bethe-approximation (array of size n)
	 * @return     status code
	'''
	tmp_array = (ctypes.c_double*n)()
	c_effective_charge= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_effective_charge_from_E_MeV_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_effective_charge)
	return c_output,  c_effective_charge._obj


def AT_max_E_transfer_MeV ( n, E_MeV_u, max_E_transfer_MeV):
	'''
	 * Kinetic energy maximally transferred from an ion to an electron
	 * in a collision - relativistic or non-relativistic
	 *
	 * @param[in]  n                        number of particles
	 * @param[in]  E_MeV_u                  energies of particle per nucleon [MeV/u]; if positive, the computation will be relativistic; if negative, the classic formular will be used (array of size n)
	 * @param[out] max_E_transfer_MeV       maximal energies transferred (array of size n)
	 * @return     status code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_max_E_transfer_MeV= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_max_E_transfer_MeV
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_max_E_transfer_MeV)
	return c_output,  c_max_E_transfer_MeV._obj


def AT_momentum_MeV_c_u_from_E_MeV_u ( n, E_MeV_u, momentum_MeV_c):
	'''
	 *  Returns relativistic momenta per nucleon for particles with given kinetic energy
	 *
	 * @param[in]	n						number of particles
	 * @param[in]  	E_MeV_u                 kinetic energy per nucleon (array of size n)
	 * @param[out]	momentum_MeV_c  		momentum per nucleon (array of size n)
	 * @return                              return code
	'''
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array = (ctypes.c_double*n)()
	c_momentum_MeV_c= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_momentum_MeV_c_u_from_E_MeV_u
	c_function.restype = ctypes.c_int
	c_output = c_function( c_n, c_E_MeV_u, c_momentum_MeV_c)
	return c_output,  c_momentum_MeV_c._obj


def AT_dose_Gy_from_fluence_cm2 ( n, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no, dose_Gy):
	'''
	 * Returns dose in Gy for each given particle
	 * @param[in]  n            number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no  type of the particles in the mixed particle field (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluence for each particle type (array of size n)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  stopping power source index
	 * @param[out] dose_Gy          be allocated by the user which will be used to return the results (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array = (ctypes.c_double*n)()
	c_dose_Gy= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_dose_Gy_from_fluence_cm2
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no, c_dose_Gy)
	return c_output,  c_dose_Gy._obj


def AT_fluence_cm2_from_dose_Gy ( n, E_MeV_u, particle_no, D_Gy, material_no, stopping_power_source_no, fluence_cm2):
	'''
	 * Returns fluence in 1/cm2 for each given particle
	 * @param[in]  n            number of particle types in the mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size n)
	 * @param[in]  particle_no  type of the particles in the mixed particle field (array of size n)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  D_Gy         dose / Gy for each particle type (array of size n)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @param[out] fluence_cm2         to be allocated by the user which will be used to return the results (array of size n)
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(D_Gy)
	c_D_Gy = ctypes.byref(tmp_array(*D_Gy))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_fluence_cm2_from_dose_Gy
	c_output = c_function( c_n, c_E_MeV_u, c_particle_no, c_D_Gy, c_material_no, c_stopping_power_source_no, c_fluence_cm2)
	return c_output,  c_fluence_cm2._obj


def AT_beam_par_physical_to_technical ( n, fluence_cm2, sigma_cm, N, FWHM_mm):
	'''
	 * Converts physical beam parameters of a symmetric, double lateral Gaussian shape beam, i.e.
	 * central (=peak) fluence and width (= 1 standard deviation)
	 * to technical, accelerator parameters, i.e.
	 * total number of particles and FWHM
	 *
	 * @param[in]      n             length of vectors for parameters
	 * @param[in]      fluence_cm2   fluence in beam center (array of size n)
	 * @param[in]      sigma_cm      beam width stdev (array of size n)
	 * @param[out]     N             resulting absolute particle numbers (array of size n)
	 * @param[out]     FWHM_mm       resulting FWHMs (in mm) (array of size n)
	'''
	tmp_array =ctypes.c_double* len(sigma_cm)
	c_sigma_cm = ctypes.byref(tmp_array(*sigma_cm))

	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array = (ctypes.c_double*n)()
	c_N= ctypes.byref(tmp_array)

	tmp_array = (ctypes.c_double*n)()
	c_FWHM_mm= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beam_par_physical_to_technical
	c_output = c_function( c_n, c_fluence_cm2, c_sigma_cm, c_N, c_FWHM_mm)
	return c_output,  c_N._obj, c_FWHM_mm._obj


def AT_beam_par_technical_to_physical ( n, N, FWHM_mm, fluence_cm2, sigma_cm):
	'''
	 * Converts technical, accelerator parameters of a symmetric, double lateral Gaussian shape beam, i.e.
	 * total number of particles and FWHM to
	 * physical beam parameters, i.e.
	 * central (=peak) fluence and width (= 1 standard deviation)
	 *
	 * @param[in]      n             length of vectors for parameters
	 * @param[in]      N             absolute particle numbers (array of size n)
	 * @param[in]      FWHM_mm       FWHMs (in mm) (array of size n)
	 * @param[out]     fluence_cm2   resulting fluence in beam center (array of size n)
	 * @param[out]     sigma_cm      resulting beam width stdev (array of size n)
	'''
	tmp_array = (ctypes.c_double*n)()
	c_sigma_cm= ctypes.byref(tmp_array)

	tmp_array =ctypes.c_double* len(FWHM_mm)
	c_FWHM_mm = ctypes.byref(tmp_array(*FWHM_mm))

	tmp_array =ctypes.c_double* len(N)
	c_N = ctypes.byref(tmp_array(*N))

	tmp_array = (ctypes.c_double*n)()
	c_fluence_cm2= ctypes.byref(tmp_array)

	c_n = ctypes.c_long(n)
	c_function =  libamtrack.AT_beam_par_technical_to_physical
	c_output = c_function( c_n, c_N, c_FWHM_mm, c_fluence_cm2, c_sigma_cm)
	return c_output,  c_fluence_cm2._obj, c_sigma_cm._obj


def AT_total_D_Gy ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the total dose of a mixed particle field
	 *
	 * @param[in]  number_of_field_components            number of components in the mixed field
	 * @param[in]  E_MeV_u                               energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no                           particle index (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2                           fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no                           material index
	 * @see AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no              TODO
	 * @return     total_dose_Gy                         result
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_total_D_Gy
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_total_fluence_cm2 ( number_of_field_components, E_MeV_u, particle_no, D_Gy, material_no, stopping_power_source_no):
	'''
	 * Computes the total fluence of a mixed particle field
	 *
	 * @param[in]  number_of_field_components            number of components in the mixed field
	 * @param[in]  E_MeV_u                               energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no                           particle index (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]  D_Gy                                  doses of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no                           material index
	 * @param[in]  stopping_power_source_no              TODO
	 * @see AT_DataMaterial.h for definition
	 * @return     total_fluence_cm                      result
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(D_Gy)
	c_D_Gy = ctypes.byref(tmp_array(*D_Gy))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_function =  libamtrack.AT_total_fluence_cm2
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_D_Gy, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_fluence_weighted_E_MeV_u ( number_of_field_components, E_MeV_u, fluence_cm2):
	'''
	 * Computes the fluence-weighted average energy of a particle field
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @return     average_E_MeV_u  fluence-weighted mean energy
	'''
	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_fluence_weighted_E_MeV_u
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_fluence_cm2)
	return c_output


def AT_dose_weighted_E_MeV_u ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the dose-weighted average energy of a particle field
	 *
	 * Needed by SuccessiveConvolutions
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     dose-weighted mean energy
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_dose_weighted_E_MeV_u
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_fluence_weighted_LET_MeV_cm2_g ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the fluence-weighted average LET of a particle field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     fluence-weighted LET
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_fluence_weighted_LET_MeV_cm2_g
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_dose_weighted_LET_MeV_cm2_g ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, stopping_power_source_no):
	'''
	 * Computes the dose-weighted average LET of a particle field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     dose-weighted LET
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_function =  libamtrack.AT_dose_weighted_LET_MeV_cm2_g
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_stopping_power_source_no)
	return c_output


def AT_stopping_power_ratio ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, reference_material_no, stopping_power_source_no):
	'''
	 * Computes the stopping power ratio for a material and a reference material.
	 *
	 * In case of mixed particle fields, the stopping power ratios of individual components are
	 * weighted by their respective fluences. Thus, this routines computes the ration of fluence-weighted
	 * stopping powers, NOT of dose-weighted stopping powers.
	 *
	 * @param[in]  number_of_field_components            number of components in mixed field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  reference_material_no  material index of reference material
	 * @param[in]  stopping_power_source_no  TODO
	 * @return     stopping power ratio
	'''
	c_material_no = ctypes.c_long(material_no)
	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	c_reference_material_no = ctypes.c_long(reference_material_no)
	c_function =  libamtrack.AT_stopping_power_ratio
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_reference_material_no, c_stopping_power_source_no)
	return c_output


def AT_mean_number_of_tracks_contrib ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2, material_no, er_model, stopping_power_source_no):
	'''
	 * Computes the number of track contributing to a representative point in a mixed field
	 *
	 * @param[in]  number_of_field_components            number of components in mixed particle field
	 * @param[in]  E_MeV_u      energy of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  particle_no  particle index (array of size number_of_field_components)
	 * @see          AT_DataParticle.h for definition
	 * @param[in]  fluence_cm2  fluences of particles in the mixed particle field (array of size number_of_field_components)
	 * @param[in]  material_no  material index
	 * @see          AT_DataMaterial.h for definition
	 * @param[in]  er_model     chosen electron-range-model
	 * @param[in]  stopping_power_source_no     TODO
	 * @return     resulting mean number of tracks contributing
	'''
	c_material_no = ctypes.c_long(material_no)
	c_er_model = ctypes.c_long(er_model)
	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	tmp_array =ctypes.c_double* len(fluence_cm2)
	c_fluence_cm2 = ctypes.byref(tmp_array(*fluence_cm2))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_function =  libamtrack.AT_mean_number_of_tracks_contrib
	c_function.restype = ctypes.c_double
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2, c_material_no, c_er_model, c_stopping_power_source_no)
	return c_output


def AT_run_IGK_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, saturation_cross_section_factor, write_output, relative_efficiency, S_HCP, S_gamma, sI_cm2, gamma_dose_Gy, P_I, P_g):
	'''
	 * Computes HCP response and relative efficiency/RBE using Katz\' Ion-Gamma-Kill approach
	 * according to Waligorski, 1988
	 *
	 * @param[in]      number_of_field_components       number of components in the mixed particle field
	 * @param[in]      E_MeV_u                          particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                      particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy           if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                      index number for detector material
	 * @param[in]      stopping_power_source_no         stopping power source number (PSTAR,...)
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      rdd_model                        index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                   parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                         index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                      index number for chosen gamma response
	 * @param[in]      gamma_parameters                 parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in]      saturation_cross_section_factor  scaling factor for the saturation cross section
	 * @see Waligorski, 1988
	 * @param[in]      write_output                     if true, a protocol is written to a file in the working directory
	 * @param[out]     relative_efficiency              particle response at dose D / gamma response at dose D
	 * @param[out]     S_HCP                            absolute particle response
	 * @param[out]     S_gamma                          absolute gamma response
	 * @param[out]     sI_cm2                           resulting ion saturation cross section in cm2
	 * @param[out]     gamma_dose_Gy                    dose contribution from gamma kills
	 * @param[out]     P_I                              ion kill probability
	 * @param[out]     P_g                              gamma kill probability
	'''
	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_sI_cm2 =  ctypes.byref(ctypes.c_double(sI_cm2))

	c_P_g =  ctypes.byref(ctypes.c_double(P_g))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_saturation_cross_section_factor = ctypes.c_double(saturation_cross_section_factor)
	c_write_output = ctypes.c_bool(write_output)
	c_P_I =  ctypes.byref(ctypes.c_double(P_I))

	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_gamma_model = ctypes.c_long(gamma_model)
	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_er_model = ctypes.c_long(er_model)
	c_gamma_dose_Gy =  ctypes.byref(ctypes.c_double(gamma_dose_Gy))

	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_IGK_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_saturation_cross_section_factor, c_write_output, c_relative_efficiency, c_S_HCP, c_S_gamma, c_sI_cm2, c_gamma_dose_Gy, c_P_I, c_P_g)
	return c_output,  c_relative_efficiency._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_sI_cm2._obj.value, c_gamma_dose_Gy._obj.value, c_P_I._obj.value, c_P_g._obj.value


def AT_run_GSM_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, N_runs, write_output, nX, voxel_size_m, lethal_events_mode, relative_efficiency, d_check, S_HCP, S_gamma, n_particles, sd_relative_efficiency, sd_d_check, sd_S_HCP, sd_S_gamma, sd_n_particles):
	'''
	 * Computes HCP response and relative efficiency/RBE using summation of tracks
	 * an a Cartesian grid (the \'GSM\' algorithm).
	 *
	 * Be aware that this routine can take considerable time to compute depending on
	 * the arguments, esp. for higher energy (>10 MeV/u) particles. It is therefore
	 * advantageous to test your settings with a low number of runs first.
	 *
	 * @param[in]      number_of_field_components     number of components in the mixed particle field
	 * @param[in]      E_MeV_u                        particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                    particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy         if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                    index number for detector material
	 * @param[in]      stopping_power_source_no       TODO
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      rdd_model                      index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                 parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                       index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                    index number for chosen gamma response
	 * @param[in]      gamma_parameters               parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in]      N_runs                         number of runs within which track positions will be resampled
	 * @param[in]      write_output                   if true, a protocol is written to "SuccessiveConvolutions.txt" in the working directory
	 * @param[in]      nX                             number of voxels of the grid in x (and y as the grid is quadratic)
	 * @param[in]      voxel_size_m                   side length of a voxel in m
	 * @param[in]      lethal_events_mode             if true, allows to do calculations for cell survival
	 * @param[out]     relative_efficiency            particle response at dose D / gamma response at dose D
	 * @param[out]     d_check                        sanity check:  total dose (in Gy) as returned by the algorithm
	 * @param[out]     S_HCP                          absolute particle response
	 * @param[out]     S_gamma                        absolute gamma response
	 * @param[out]     n_particles                    average number of particle tracks on the detector grid
	 * @param[out]     sd_relative_efficiency         standard deviation for relative_efficiency
	 * @param[out]     sd_d_check                     standard deviation for d_check
	 * @param[out]     sd_S_HCP                       standard deviation for S_HCP
	 * @param[out]     sd_S_gamma                     standard deviation for S_gamma
	 * @param[out]     sd_n_particles                 standard deviation for n_particles
	'''
	c_voxel_size_m = ctypes.c_double(voxel_size_m)
	c_sd_S_HCP =  ctypes.byref(ctypes.c_double(sd_S_HCP))

	c_er_model = ctypes.c_long(er_model)
	c_nX = ctypes.c_long(nX)
	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	c_sd_n_particles =  ctypes.byref(ctypes.c_double(sd_n_particles))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	c_N_runs = ctypes.c_long(N_runs)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_n_particles =  ctypes.byref(ctypes.c_double(n_particles))

	c_sd_d_check =  ctypes.byref(ctypes.c_double(sd_d_check))

	c_gamma_model = ctypes.c_long(gamma_model)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_sd_S_gamma =  ctypes.byref(ctypes.c_double(sd_S_gamma))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	c_write_output = ctypes.c_bool(write_output)
	c_d_check =  ctypes.byref(ctypes.c_double(d_check))

	c_sd_relative_efficiency =  ctypes.byref(ctypes.c_double(sd_relative_efficiency))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_GSM_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_N_runs, c_write_output, c_nX, c_voxel_size_m, c_lethal_events_mode, c_relative_efficiency, c_d_check, c_S_HCP, c_S_gamma, c_n_particles, c_sd_relative_efficiency, c_sd_d_check, c_sd_S_HCP, c_sd_S_gamma, c_sd_n_particles)
	return c_output,  c_relative_efficiency._obj.value, c_d_check._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_n_particles._obj.value, c_sd_relative_efficiency._obj.value, c_sd_d_check._obj.value, c_sd_S_HCP._obj.value, c_sd_S_gamma._obj.value, c_sd_n_particles._obj.value


def AT_run_CPPSC_method ( number_of_field_components, E_MeV_u, particle_no, fluence_cm2_or_dose_Gy, material_no, stopping_power_source_no, rdd_model, rdd_parameters, er_model, gamma_model, gamma_parameters, N2, fluence_factor, write_output, shrink_tails, shrink_tails_under, adjust_N2, lethal_events_mode, relative_efficiency, d_check, S_HCP, S_gamma, mean_number_of_tracks_contrib, start_number_of_tracks_contrib, n_convolutions, lower_Jensen_bound, upper_Jensen_bound):
	'''
	 * Computes HCP response and relative efficiency/RBE using compound Poison processes and
	 * successive convolutions (CPP_SC, the \'SPIFF\' algorithm)
	 *
	 * @param[in]      number_of_field_components     number of components in the mixed particle field
	 * @param[in]      E_MeV_u                        particle energy for each component in the mixed particle field [MeV/u] (array of size number_of_field_components)
	 * @param[in]      particle_no                    particle type for each component in the mixed particle field (array of size number_of_field_components)
	 * @see AT_DataParticle.h for definition
	 * @param[in]      fluence_cm2_or_dose_Gy         if positive, particle fluence for each component in the mixed particle field [1/cm2]; if negative, particle dose for each component in the mixed particle field [Gy] (array of size number_of_field_components)
	 * @param[in]      material_no                    index number for detector material
	 * @see AT_DataMaterial.h for definition
	 * @param[in]      stopping_power_source_no       TODO
	 * @param[in]      rdd_model                      index number for chosen radial dose distribution
	 * @param[in]      rdd_parameters                 parameters for chosen radial dose distribution (array of size 4)
	 * @see AT_RDD.h for definition
	 * @param[in]      er_model                       index number for chosen electron-range model
	 * @see AT_ElectronRange.h for definition
	 * @param[in]      gamma_model                    index number for chosen gamma response
	 * @param[in]      gamma_parameters               parameters for chosen gamma response (array of size 9)
	 * @see AT_GammaResponse.h for definition
	 * @param[in,out]  N2                             number of bins per factor of two for the dose scale of local dose histogram
	 * @param[in]      fluence_factor                 factor to scale the fluences / doses given in "fluence_cm2_or_dose_Gy" with
	 * @param[in]      write_output                   if true, a log-file is written to "SuccessiveConvolutions.txt" in the working directory
	 * @param[in]      shrink_tails                   if true, tails of the local dose distribution, contributing less than "shrink_tails_under" are cut
	 * @param[in]      shrink_tails_under             limit for tail cutting in local dose distribution
	 * @param[in]      adjust_N2                      if true, "N2" will be increase if necessary at high fluence to ensure sufficient local dose histogram resolution
	 * @param[in]      lethal_events_mode             if true, computations are done for dependent subtargets
	 * @param[out]     relative_efficiency            particle response at dose D / gamma response at dose D
	 * @param[out]     d_check                        sanity check:  total dose (in Gy) as returned by the algorithm
	 * @param[out]     S_HCP                          absolute particle response
	 * @param[out]     S_gamma                        absolute gamma response
	 * @param[out]     mean_number_of_tracks_contrib  mean number of tracks contributing to representative point
	 * @param[out]     start_number_of_tracks_contrib low fluence approximation for mean number of tracks contributing to representative point (start value for successive convolutions)
	 * @param[out]     n_convolutions                 number of convolutions performed to reach requested dose/fluence
	 * @param[out]     lower_Jensen_bound             lower bound for Jensen\'s inequity
	 * @param[out]     upper_Jensen_bound             upper bound for Jensen\'s inequity
	'''
	c_n_convolutions =  ctypes.byref(ctypes.c_long(n_convolutions))

	c_er_model = ctypes.c_long(er_model)
	c_adjust_N2 = ctypes.c_bool(adjust_N2)
	c_S_HCP =  ctypes.byref(ctypes.c_double(S_HCP))

	tmp_array =ctypes.c_long* len(particle_no)
	c_particle_no = ctypes.byref(tmp_array(*particle_no))

	c_lethal_events_mode = ctypes.c_bool(lethal_events_mode)
	tmp_array =ctypes.c_double* len(fluence_cm2_or_dose_Gy)
	c_fluence_cm2_or_dose_Gy = ctypes.byref(tmp_array(*fluence_cm2_or_dose_Gy))

	c_material_no = ctypes.c_long(material_no)
	c_rdd_model = ctypes.c_long(rdd_model)
	c_upper_Jensen_bound =  ctypes.byref(ctypes.c_double(upper_Jensen_bound))

	c_shrink_tails_under = ctypes.c_double(shrink_tails_under)
	c_write_output = ctypes.c_bool(write_output)
	c_gamma_model = ctypes.c_long(gamma_model)
	c_stopping_power_source_no = ctypes.c_long(stopping_power_source_no)
	c_S_gamma =  ctypes.byref(ctypes.c_double(S_gamma))

	c_start_number_of_tracks_contrib =  ctypes.byref(ctypes.c_double(start_number_of_tracks_contrib))

	c_relative_efficiency =  ctypes.byref(ctypes.c_double(relative_efficiency))

	tmp_array =ctypes.c_double* len(E_MeV_u)
	c_E_MeV_u = ctypes.byref(tmp_array(*E_MeV_u))

	c_number_of_field_components = ctypes.c_long(number_of_field_components)
	c_lower_Jensen_bound =  ctypes.byref(ctypes.c_double(lower_Jensen_bound))

	c_N2 = ctypes.c_long(N2)
	c_mean_number_of_tracks_contrib =  ctypes.byref(ctypes.c_double(mean_number_of_tracks_contrib))

	c_fluence_factor = ctypes.c_double(fluence_factor)
	tmp_array =ctypes.c_double* len(gamma_parameters)
	c_gamma_parameters = ctypes.byref(tmp_array(*gamma_parameters))

	c_shrink_tails = ctypes.c_bool(shrink_tails)
	c_d_check =  ctypes.byref(ctypes.c_double(d_check))

	tmp_array =ctypes.c_double* len(rdd_parameters)
	c_rdd_parameters = ctypes.byref(tmp_array(*rdd_parameters))

	c_function =  libamtrack.AT_run_CPPSC_method
	c_output = c_function( c_number_of_field_components, c_E_MeV_u, c_particle_no, c_fluence_cm2_or_dose_Gy, c_material_no, c_stopping_power_source_no, c_rdd_model, c_rdd_parameters, c_er_model, c_gamma_model, c_gamma_parameters, c_N2, c_fluence_factor, c_write_output, c_shrink_tails, c_shrink_tails_under, c_adjust_N2, c_lethal_events_mode, c_relative_efficiency, c_d_check, c_S_HCP, c_S_gamma, c_mean_number_of_tracks_contrib, c_start_number_of_tracks_contrib, c_n_convolutions, c_lower_Jensen_bound, c_upper_Jensen_bound)
	return c_output,  c_relative_efficiency._obj.value, c_d_check._obj.value, c_S_HCP._obj.value, c_S_gamma._obj.value, c_mean_number_of_tracks_contrib._obj.value, c_start_number_of_tracks_contrib._obj.value, c_n_convolutions._obj.value, c_lower_Jensen_bound._obj.value, c_upper_Jensen_bound._obj.value

